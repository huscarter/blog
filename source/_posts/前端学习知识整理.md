---
title: 前端学习知识整理
date: 2024-01-01 13:01:01
categories: web
tags:
     - web
description: 渡一前端学习知识总结。
---

## 事件循环
### 浏览器的进程模型
1. 进程和线程
进程是系统进行资源调度的基本单位，一个进程可包含多个线程，线程是系统进行运算调度的最小单位。

2. 浏览器的三大进程

- 浏览器进程
浏览器事件、管理tab等浏览器操作

- 网络进程
实现浏览中的网络请求

- 渲染进程
每个tab新开一个进程，处理html、css、js等代码执行

3. 渲染主线程

- 渲染主线程如何实现异步
```
js是一⻔单线程的语言，这是因为它运行在浏览器的渲染主线程中，而渲染主线程只有一个。
渲染主线程承担着诸多的工作，渲染⻚面、执行js都在其中运行。如果使用同步的方式，就极有可能导致主线程产生阻塞，从而导致消息队列中的很多其他任务无法得到执行。
这样一来，一方面会导致繁忙的主线程白白的消耗时间，另一方面导致⻚面无法及时更新，给用户造成卡死现象。
所以浏览器采用异步的方式来避免。具体做法是当某些任务发生时，比如计时器、网络、事件监听，主线程将任务交给其他线程去处理，自身立即结束任务的执行，转而执行后续代码。
当其他线程完成时将事先传递的回调函数包装成任务，加入到消息队列的末尾排队等待主线程调度执行。在这种异步模式下浏览器永不阻塞，从而最大限度的保证了单线程的流畅运行。
```

- JS的事件循环
```
事件循环又叫做消息循环，是浏览器渲染主线程的工作方式。
在Chrome的源码中，它开启一个不会结束的for循环，每次循环从消息队列中取出第一个任务执行，而其他线程只需要在合适的时候将任务加入到队列末尾即可。过去把消息队列简单分为宏队列和微队列，这种说法目前已无法满足复杂的 浏览器环境，取而代之的是一种更加灵活多变的处理方式。
根据W3C官方的解释，每个任务有不同的类型，同类型的任务必须在同一个队列，不同的任务可以属于不同的队列。不同任务队列有不同的优先级， 在一次事件循环中，由浏览器自行决定取哪一个队列的任务。但浏览器必须有一个微队列，微队列的任务一定具有最高的优先级，必须优先调度执行。
```

- 消息队列优先级
1）延时队列:用于存放计时器到达后的回调任务，优先级「中」 
2）交互队列:用于存放用户操作后产生的事件处理任务，优先级「高」 
3）微队列:用户存放需要最快执行的任务，优先级「最高」
```
Promise.resolve().then(function) 可将function函数放入微队列
```

### 浏览器的渲染原理
1. 浏览器通过网络进程获取html交给渲染进程渲染。

2. 渲染进程生成渲染任务交给消息队列，渲染主线程根据任务队列中的任务进行渲染。

- 解析html (Parse html)
1) 生成dom树，js中通过document对象操作dom树。
2）生成cssom树，js中通过documn.styleSheets获取cssom树对其操作。
3）解析遇到css代码，浏览器会启动一个预解析器去先下载和解析css。解析遇到js代码，渲染主线程会暂停等网络线程下载完js后再解析js。

- 样式计算 (Recalculate style)
主线程依次为树中的每个节点计算出它最终的样式，在这一过程中很多预设值会变成绝对值，比如`red`会变成`rgb(255,0,0)`；相对单位会变成绝对单位，比如`em`会变成`px`。这一步完成后，会得到一棵带有样式的DOM树。

- 布局 (Layout)
根据css样式计算dom节点的几何信息，例如节点尺寸、相对包含块的位置。完成后会得到布局树，因为受css样式影响，dom树和布局树并不一一对应。

- 分层 (Layer)
为了提高重绘效率，浏览器会将页面划分若干层，每次重绘只会重新渲染对应分层的内容。可以通过will-change: [transform]属性来影响分层。

- 生成绘制指令 (Paint)
主线程会为每个层单独产生绘制指令集，用于描述这一层的内容该如何画出来。之后主线程将绘制指令集交给合成线程，之后的工作将由合成线程完成。

- 分块 (Tiling)
为了提高效率，合成线程将每个图层进行更小区域的分块，合成线程通过线程池完成此工作。

- 光栅化 (Raster)
分块完成后合成线程将分块信息交给GPU进程，GPU进程会先将靠近视口的分块光栅化（即计算出每块的位图[像素信息]）。此步骤会涉及GPU硬件加速。

- 画 （Draw）
合成线程拿到每个层、每个块的位图后，生成一个个「指引（quad）」信息。指引会标识出每个位图应该画到屏幕的哪个位置，以及会考虑到旋转、缩放等变形。变形发生在合成线程，与渲染主线程无关，这就是`transform`效率高的本质原因。最终合成线程会把 quad 提交给 GPU 进程，由 GPU 进程产生系统调用，提交给 GPU 硬件，完成最终的屏幕成像。

### 案例知识
1. 歌词滚动
- html 标签boolean属性可以直接写属性名，即为true

- lorem 乱数假文
```
lorem 随机生成一段话
lorem4 随机生成4个单词
li*30>lorem4 生成30个li，每个里面的内容是4个随机单词
```

- 行盒（如span）、块盒（如div）

- 字体大小变化推荐使用transform控制性能更好,（因为transform是合成线程处理的）
```
transform:  scale(1.2);
transition: 0.2s; // 过渡时间
```

### 购物车
1. 通过class 将业务逻辑抽离封装
```
class Ui {
  constructor() {
    this.goodsData = new GoodsData();
    this.uiData = new UiData();
  }
}

class GoodsData{
  constructor() {
  }
}

class UiData {
  constructor() {
  }
}
```

2. 水波纹效果
```
// html
<div class="water-animate">test animate</div>

// css
.water-animate {
  animation: water 500ms ease-in-out;;
}
@keyframes water {
  0% {transform: scale(1);}
  25% {transform: scale(0.8);}
  50% {transform: scale(1.1);}
  75% {transform: scale(0.9);}
  100% {transform: scale(1.1);}
}

```

3. 抛物线图标移动效果
```
// html
<div id="wrp" class="wrp-css">
  <img id="icon" class="icon-css" src="xxx.png" />
</div>

// js
// 父层
wrp.style.transform = 'translateX(start)';
wrp.clientWidth // 强制渲染
wrp.style.transform = 'translateX(end)';
// 子层icon
icon.style.transform = 'translateY(start)';
icon.style.transform = 'translateY(end)';

// css
.wrp-css{
  transition: 1s linear;
}
.icon-css{
  transition: 1s cubic-bezier(0.5, -0.5, 1,1); // 抛物线
}

```

4. 属性描述符
```
class Person {
  constructor(_data) {
    // 属性描述符用于设置对象属性的各种规则，以确保对象属性在使用时的行为符合预期
    Object.defineProperties(this, 'data', {
      value: _data,
      freeze: true, // 冻结（不可更改），默认false
      writable: true, // 可重写，默认true
      configurable: false, // 不可重新定义
      enumerable: true, // 可遍历，默认true
      get: function() {return this.data;}
      set: function(value) { 
        if(typeof value !== 'object' ) {
          throw new Error('value must be object')
        }
        this.data = value;
      }
    }
    Object.seal(this); // 对象不可增加属性
    Object.freeze(this); // 对象被冻结
  }
}
```
